<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Crypto ML Platform | XRP, XLM, Bitcoin Price Prediction</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.2.0/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ffd700, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
            margin-bottom: 20px;
        }
        
        .author-credit {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
            backdrop-filter: blur(10px);
        }
        
        .unt-badge {
            position: fixed;
            top: 20px;
            left: 20px;
            background: linear-gradient(45deg, #00853e, #005a27);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 0.9em;
            box-shadow: 0 4px 15px rgba(0, 133, 62, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .unt-badge:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 133, 62, 0.4);
        }
        
        .eagle-icon {
            font-size: 1.2em;
        }
        
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .control-panel {
            grid-column: 1 / -1;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            min-width: 120px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        select, input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 10px;
            color: white;
            margin: 5px;
        }
        
        select option {
            background: #2a5298;
            color: white;
        }
        
        .chart-container {
            position: relative;
            height: 400px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 10px;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .metric {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #ffd700;
        }
        
        .metric-label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 5px;
        }
        
        .status {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid rgba(0, 255, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .log {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            margin-top: 15px;
        }
        
        .feature-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        
        .feature-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
            .button-group {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="unt-badge">
            <span class="eagle-icon">ü¶Ö</span>
            <span>UNT Alumni</span>
        </div>
        
        <div class="header">
            <h1>üöÄ Multi-Crypto ML Platform</h1>
            <p class="subtitle">Advanced Price Prediction for 8 Major Cryptocurrencies</p>
            
            <div class="author-credit">
                <h3>üéØ Advanced ML Portfolio Project</h3>
                <p>Multi-asset cryptocurrency analysis with real-time data integration</p>
                <p><strong>Coverage:</strong> Bitcoin, Ethereum, Cardano, Solana, Hedera, Algorand, XRP, Stellar</p>
            </div>
        </div>
        
        <div class="card control-panel">
            <h3>üéØ ML Pipeline Control</h3>
            <div class="button-group">
                <button onclick="fetchRealData()">üìä Load Real Data</button>
                <button onclick="generateData()">üé≤ Generate Sample Data</button>
                <button onclick="engineerFeatures()" id="featuresBtn" disabled>‚öôÔ∏è Engineer Features</button>
                <button onclick="trainModel()" id="trainBtn" disabled>üß† Train Model</button>
                <button onclick="makePrediction()" id="predictBtn" disabled>üîÆ Predict Price</button>
            </div>
            
            <div>
                <label>Cryptocurrency:</label>
                <select id="cryptoType" onchange="updateCrypto()">
                    <optgroup label="Layer 1 Blockchains">
                        <option value="btc">Bitcoin (BTC)</option>
                        <option value="eth">Ethereum (ETH)</option>
                        <option value="ada">Cardano (ADA)</option>
                        <option value="sol">Solana (SOL)</option>
                    </optgroup>
                    <optgroup label="Enterprise & DeFi">
                        <option value="hbar">Hedera (HBAR)</option>
                        <option value="algo">Algorand (ALGO)</option>
                    </optgroup>
                    <optgroup label="Payment & Transfer">
                        <option value="xrp">XRP (Ripple)</option>
                        <option value="xlm">Stellar Lumens (XLM)</option>
                    </optgroup>
                </select>
                
                <label>Data Period:</label>
                <select id="dataPeriod">
                    <option value="7">7 Days (Hourly)</option>
                    <option value="30">30 Days (Hourly)</option>
                    <option value="90">90 Days (Daily)</option>
                    <option value="365" selected>1 Year (Daily)</option>
                </select>
                
                <label>Model:</label>
                <select id="modelType">
                    <option value="neural">Neural Network</option>
                    <option value="linear">Linear Regression</option>
                </select>
            </div>
            
            <div class="status" id="status">
                üí° Welcome! Select data period and click "Load Real Data" for live analysis up to current time.
            </div>
        </div>
        
        <div class="grid">
            <div class="card">
                <h3>üìà Price Chart</h3>
                <div class="chart-container">
                    <canvas id="priceChart"></canvas>
                </div>
            </div>
            
            <div class="card">
                <h3>üìä Performance Metrics</h3>
                <div class="metrics" id="metrics">
                    <div class="metric">
                        <div class="metric-value" id="accuracy">-</div>
                        <div class="metric-label">Accuracy</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="mae">-</div>
                        <div class="metric-label">Mean Error</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card">
            <h3>üìù Activity Log</h3>
            <div class="log" id="trainingLog"></div>
        </div>
    </div>

    <script>
        let rawData = [];
        let features = [];
        let trainedModel = null;
        let priceChart = null;
        let currentCrypto = 'btc';
        
        const cryptoConfig = {
            btc: { name: 'Bitcoin', symbol: 'BTC', id: 'bitcoin', color: '#f7931a' },
            eth: { name: 'Ethereum', symbol: 'ETH', id: 'ethereum', color: '#627eea' },
            ada: { name: 'Cardano', symbol: 'ADA', id: 'cardano', color: '#0033ad' },
            sol: { name: 'Solana', symbol: 'SOL', id: 'solana', color: '#9945ff' },
            hbar: { name: 'Hedera', symbol: 'HBAR', id: 'hedera-hashgraph', color: '#00b4aa' },
            algo: { name: 'Algorand', symbol: 'ALGO', id: 'algorand', color: '#000000' },
            xrp: { name: 'XRP', symbol: 'XRP', id: 'ripple', color: '#00aae4' },
            xlm: { name: 'Stellar', symbol: 'XLM', id: 'stellar', color: '#7c4dff' }
        };
        
        function log(message) {
            const logDiv = document.getElementById('trainingLog');
            const timestamp = new Date().toLocaleTimeString();
            logDiv.innerHTML += `[${timestamp}] ${message}\n`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        function updateStatus(message) {
            document.getElementById('status').innerHTML = message;
        }
        
        function updateCrypto() {
            currentCrypto = document.getElementById('cryptoType').value;
            const config = cryptoConfig[currentCrypto];
            log(`üîÑ Switched to ${config.name}`);
            updateStatus(`üí∞ Selected ${config.name}. Click Generate Data to start.`);
            
            // Reset everything
            rawData = [];
            features = [];
            trainedModel = null;
            document.getElementById('featuresBtn').disabled = true;
            document.getElementById('trainBtn').disabled = true;
            document.getElementById('predictBtn').disabled = true;
            document.getElementById('accuracy').textContent = '-';
            document.getElementById('mae').textContent = '-';
            
            if (priceChart) {
                priceChart.destroy();
                priceChart = null;
            }
        }
        
        async function fetchRealData() {
            const config = cryptoConfig[currentCrypto];
            log(`üåê Fetching real ${config.name} data from CoinGecko...`);
            updateStatus(`üì° Loading live market data for ${config.name}...`);
            
            try {
                // CoinGecko API - free tier, no API key required
                const response = await fetch(`https://api.coingecko.com/api/v3/coins/${config.id}/market_chart?vs_currency=usd&days=365&interval=daily`);
                
                if (!response.ok) {
                    throw new Error(`API Error: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Transform API data to our format
                rawData = data.prices.map(([timestamp, price]) => ({
                    date: new Date(timestamp),
                    price: price,
                    volume: data.total_volumes.find(v => v[0] === timestamp)?.[1] || 0
                }));
                
                log(`‚úÖ Loaded ${rawData.length} days of real market data`);
                log(`üìà Price range: ${Math.min(...rawData.map(d => d.price)).toFixed(currentCrypto === 'btc' ? 0 : 3)} - ${Math.max(...rawData.map(d => d.price)).toFixed(currentCrypto === 'btc' ? 0 : 3)}`);
                log(`üìä Latest price: ${rawData[rawData.length - 1].price.toFixed(currentCrypto === 'btc' ? 0 : 3)}`);
                log(`üóìÔ∏è Data period: ${rawData[0].date.toLocaleDateString()} to ${rawData[rawData.length - 1].date.toLocaleDateString()}`);
                
                createChart();
                document.getElementById('featuresBtn').disabled = false;
                updateStatus(`‚úÖ Real ${config.name} data loaded! Ready for ML analysis with live market data.`);
                
            } catch (error) {
                log(`‚ùå Error fetching data: ${error.message}`);
                log(`üîÑ Falling back to sample data...`);
                updateStatus(`‚ö†Ô∏è API unavailable, using sample data. Try again later.`);
                generateData(); // Fallback to synthetic data
            }
        }
        
        function generateData() {
            const config = cryptoConfig[currentCrypto];
            log(`üé≤ Generating synthetic ${config.name} data for demo...`);
            updateStatus(`üìä Creating realistic ${config.name} price simulation...`);
            
            rawData = [];
            let price = config.id === 'bitcoin' ? 45000 : (config.id === 'ripple' ? 0.65 : 0.12);
            
            for (let i = 0; i < 365; i++) {
                // Simulate price movements
                const trend = Math.sin(i / 30) * 0.02;
                const noise = (Math.random() - 0.5) * 0.06;
                price = price * (1 + trend + noise);
                
                rawData.push({
                    date: new Date(Date.now() - (365 - i) * 24 * 60 * 60 * 1000),
                    price: Math.max(price, price * 0.1)
                });
            }
            
            log(`‚úÖ Generated ${rawData.length} days of synthetic data`);
            log(`üìà Simulated price range: ${Math.min(...rawData.map(d => d.price)).toFixed(currentCrypto === 'btc' ? 0 : 3)} - ${Math.max(...rawData.map(d => d.price)).toFixed(currentCrypto === 'btc' ? 0 : 3)}`);
            
            createChart();
            document.getElementById('featuresBtn').disabled = false;
            updateStatus(`‚úÖ Synthetic data ready! This is demo mode - click "Load Real Data" for live prices.`);
        }
        
        function createChart() {
            const ctx = document.getElementById('priceChart').getContext('2d');
            const config = cryptoConfig[currentCrypto];
            
            if (priceChart) priceChart.destroy();
            
            priceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: rawData.map(d => d.date.toLocaleDateString()),
                    datasets: [{
                        label: `${config.name} Price`,
                        data: rawData.map(d => d.price),
                        borderColor: config.color,
                        backgroundColor: config.color + '20',
                        borderWidth: 2,
                        fill: true,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { labels: { color: 'white' } }
                    },
                    scales: {
                        x: { ticks: { color: 'white', maxTicksLimit: 8 } },
                        y: { 
                            ticks: { 
                                color: 'white',
                                callback: function(value) {
                                    const decimals = currentCrypto === 'btc' ? 0 : 3;
                                    return '$' + value.toFixed(decimals);
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function engineerFeatures() {
            const config = cryptoConfig[currentCrypto];
            log(`‚öôÔ∏è Engineering features for ${config.name}...`);
            updateStatus(`üîß Creating technical indicators...`);
            
            const prices = rawData.map(d => d.price);
            
            // Simple moving averages
            const ma7 = prices.map((price, i) => {
                if (i < 6) return price;
                return prices.slice(i-6, i+1).reduce((sum, p) => sum + p, 0) / 7;
            });
            
            const ma21 = prices.map((price, i) => {
                if (i < 20) return price;
                return prices.slice(i-20, i+1).reduce((sum, p) => sum + p, 0) / 21;
            });
            
            // Create feature set
            features = rawData.map((d, i) => {
                if (i < 21 || i >= prices.length - 1) return null;
                
                return {
                    ma7: ma7[i],
                    ma21: ma21[i],
                    price: d.price,
                    nextPrice: prices[i + 1]
                };
            }).filter(f => f !== null);
            
            log(`‚úÖ Created ${features.length} feature vectors`);
            document.getElementById('trainBtn').disabled = false;
            updateStatus(`‚úÖ Features ready! Ready to train model.`);
        }
        
        async function trainModel() {
            const config = cryptoConfig[currentCrypto];
            log(`üß† Training model for ${config.name}...`);
            updateStatus(`üß† Training neural network...`);
            
            // Prepare training data
            const trainSize = Math.floor(features.length * 0.8);
            const trainData = features.slice(0, trainSize);
            const testData = features.slice(trainSize);
            
            // Normalize features
            const maxPrice = Math.max(...features.map(f => f.price));
            const normalizedTrain = trainData.map(f => ({
                inputs: [f.ma7/maxPrice, f.ma21/maxPrice, f.price/maxPrice],
                output: f.nextPrice/maxPrice
            }));
            
            const normalizedTest = testData.map(f => ({
                inputs: [f.ma7/maxPrice, f.ma21/maxPrice, f.price/maxPrice],
                output: f.nextPrice/maxPrice
            }));
            
            // Create tensors
            const trainX = tf.tensor2d(normalizedTrain.map(d => d.inputs));
            const trainY = tf.tensor2d(normalizedTrain.map(d => [d.output]));
            const testX = tf.tensor2d(normalizedTest.map(d => d.inputs));
            const testY = tf.tensor2d(normalizedTest.map(d => [d.output]));
            
            // Build model
            trainedModel = tf.sequential({
                layers: [
                    tf.layers.dense({ inputShape: [3], units: 16, activation: 'relu' }),
                    tf.layers.dense({ units: 8, activation: 'relu' }),
                    tf.layers.dense({ units: 1, activation: 'linear' })
                ]
            });
            
            trainedModel.compile({
                optimizer: tf.train.adam(0.01),
                loss: 'meanSquaredError'
            });
            
            // Train
            await trainedModel.fit(trainX, trainY, {
                epochs: 50,
                batchSize: 16,
                verbose: 0
            });
            
            // Evaluate
            const predictions = trainedModel.predict(testX);
            const predArray = await predictions.data();
            const actualArray = await testY.data();
            
            // Calculate metrics
            let mae = 0;
            for (let i = 0; i < predArray.length; i++) {
                mae += Math.abs(predArray[i] - actualArray[i]);
            }
            mae = (mae / predArray.length) * maxPrice;
            
            const accuracy = Math.max(0, 100 - (mae / (maxPrice * 0.1)) * 100);
            
            document.getElementById('accuracy').textContent = accuracy.toFixed(1) + '%';
            document.getElementById('mae').textContent = '$' + mae.toFixed(2);
            
            log(`‚úÖ Model trained! Accuracy: ${accuracy.toFixed(1)}%`);
            document.getElementById('predictBtn').disabled = false;
            updateStatus(`üéâ Model ready! You can now make predictions.`);
            
            // Cleanup
            trainX.dispose();
            trainY.dispose();
            testX.dispose();
            testY.dispose();
            predictions.dispose();
        }
        
        function makePrediction() {
            if (!trainedModel || features.length === 0) return;
            
            const config = cryptoConfig[currentCrypto];
            log(`üîÆ Making price prediction for ${config.name}...`);
            
            const lastFeature = features[features.length - 1];
            const maxPrice = Math.max(...features.map(f => f.price));
            
            const inputTensor = tf.tensor2d([[
                lastFeature.ma7/maxPrice, 
                lastFeature.ma21/maxPrice, 
                lastFeature.price/maxPrice
            ]]);
            
            const prediction = trainedModel.predict(inputTensor);
            prediction.data().then(result => {
                const predictedPrice = result[0] * maxPrice;
                const currentPrice = lastFeature.price;
                const change = ((predictedPrice / currentPrice - 1) * 100);
                const decimals = currentCrypto === 'btc' ? 0 : 3;
                
                log(`üí∞ Current: $${currentPrice.toFixed(decimals)}`);
                log(`üéØ Predicted: $${predictedPrice.toFixed(decimals)}`);
                log(`üìä Change: ${change > 0 ? '+' : ''}${change.toFixed(2)}%`);
                
                updateStatus(`üîÆ Prediction: $${predictedPrice.toFixed(decimals)} (${change > 0 ? '+' : ''}${change.toFixed(2)}%)`);
            });
            
            inputTensor.dispose();
        }
        
        // Initialize
        log("üåü Multi-Crypto ML Platform initialized");
        log("üåê Now supporting 8 major cryptocurrencies:");
        log("   Layer 1: Bitcoin, Ethereum, Cardano, Solana");
        log("   Enterprise: Hedera (HBAR), Algorand (ALGO)"); 
        log("   Payments: XRP, Stellar Lumens");
        log("üìö UNT Alumni - Advanced ML Portfolio Project");
    </script>
</body>
</html>
