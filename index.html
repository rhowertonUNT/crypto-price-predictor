<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Multi-Crypto ML Platform | Time-Series Safe</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.2.0/tf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Arial,sans-serif;background:linear-gradient(135deg,#1e3c72,#2a5298);color:#fff;min-height:100vh;padding:20px}
    .container{max-width:1200px;margin:0 auto}
    .header{text-align:center;margin-bottom:24px}
    .header h1{font-size:2rem;margin-bottom:8px;background:linear-gradient(45deg,#ffd700,#ff6b6b);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
    .card{background:rgba(255,255,255,.1);backdrop-filter:blur(10px);border-radius:14px;padding:18px;border:1px solid rgba(255,255,255,.2);margin-bottom:16px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
    @media (max-width:900px){.grid{grid-template-columns:1fr}}
    .button-group{display:flex;flex-wrap:wrap;gap:8px;margin:12px 0}
    button{background:linear-gradient(45deg,#667eea,#764ba2);color:#fff;border:0;padding:10px 16px;border-radius:10px;font-weight:600;cursor:pointer;transition:transform .15s}
    button:hover{transform:translateY(-1px)}
    button:disabled{opacity:.55;cursor:not-allowed;transform:none}
    select{background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.3);border-radius:8px;color:#fff;padding:8px}
    .chart-container{position:relative;height:420px;background:rgba(255,255,255,.05);border-radius:10px;padding:10px}
    .metrics{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:10px;margin-top:10px}
    .metric{background:rgba(255,255,255,.1);border-radius:10px;padding:12px;text-align:center}
    .metric .value{font-size:1.4rem;font-weight:700;color:#ffd700}
    .log{background:rgba(0,0,0,.35);border-radius:8px;padding:12px;height:220px;overflow:auto;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:.9rem;white-space:pre-wrap}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    .status{background:rgba(0,255,0,.1);border:1px solid rgba(0,255,0,.3);border-radius:8px;padding:12px;margin-top:10px}
    .badge{position:fixed;top:14px;left:14px;background:#005a27;color:#fff;border-radius:10px;padding:8px 12px;font-weight:700;border:1px solid rgba(255,255,255,.2)}
    table{width:100%;margin-top:10px;border-collapse:collapse}
    th,td{padding:6px}
    thead th{border-bottom:1px solid rgba(255,255,255,.3);text-align:left}
    tbody td{text-align:right}
    tbody td:first-child{text-align:left}
  </style>
</head>
<body>
  <div class="container">
    <div class="badge">ðŸ¦… UNT Alumni â€¢ Tech</div>

    <div class="header">
      <h1>Multi-Crypto ML Platform</h1>
      <p>Time-series safe training, baselines, and sequence models</p>
    </div>

    <div class="card">
      <h3>Controls</h3>
      <div class="button-group">
        <button id="btnReal" onclick="fetchRealData()">Load real data</button>
        <button id="btnGen" onclick="generateData()">Generate sample</button>
        <button id="btnFeat" onclick="engineerFeatures()" disabled>Engineer features</button>
        <button id="btnTrain" onclick="trainModel()" disabled>Train model</button>
        <button id="btnUpdate" onclick="trainModel()" disabled>Update model</button>
        <button id="btnCompare" onclick="compareAll()" disabled>Compare all models</button>
        <button id="btnPred" onclick="makePrediction()" disabled>Predict next</button>
      </div>
      <div class="row">
        <label>Asset</label>
        <select id="cryptoType" onchange="updateCrypto()">
          <optgroup label="Layer 1">
            <option value="btc">Bitcoin</option>
            <option value="eth">Ethereum</option>
            <option value="ada">Cardano</option>
            <option value="sol">Solana</option>
          </optgroup>
          <optgroup label="Enterprise and DeFi">
            <option value="hbar">Hedera</option>
            <option value="algo">Algorand</option>
          </optgroup>
          <optgroup label="Payments">
            <option value="xrp">XRP</option>
            <option value="xlm">Stellar</option>
          </optgroup>
        </select>

        <label>Period</label>
        <select id="dataPeriod">
          <option value="7">7 days hourly</option>
          <option value="30">30 days hourly</option>
          <option value="90">90 days daily</option>
          <option value="365" selected>1 year daily</option>
        </select>

        <label>Model</label>
        <select id="modelType">
          <option value="neural">MLP demo</option>
          <option value="linear">Linear</option>
          <option value="lstm">LSTM sequence</option>
        </select>
      </div>
      <div id="status" class="status">Select an asset, load real data, then engineer features.</div>
    </div>

    <div class="grid">
      <div class="card">
        <h3>Price chart</h3>
        <div class="chart-container"><canvas id="priceChart"></canvas></div>
      </div>
      <div class="card">
        <h3>Metrics</h3>
        <div class="metrics">
          <div class="metric">
            <div id="smape" class="value">-</div>
            <div>SMAPE percent</div>
          </div>
          <div class="metric">
            <div id="mae" class="value">-</div>
            <div>MAE in price units</div>
          </div>
        </div>

        <table id="resultsTable">
          <thead>
            <tr>
              <th>Model</th>
              <th style="text-align:right">MAE (price)</th>
              <th style="text-align:right">MAPE %</th>
              <th style="text-align:right">SMAPE %</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>

        <div style="margin-top:10px;font-size:.95rem">
          Baseline is naive next equals now. Table compares Baseline, Linear, MLP, and LSTM.
        </div>
      </div>
    </div>

    <div class="card">
      <h3>Log</h3>
      <div id="log" class="log"></div>
    </div>
  </div>

  <script>
    // ------------------------ State ------------------------
    let rawData = [];
    let features = null;
    let trainedModel = null;
    let priceChart = null;
    let currentCrypto = 'btc';
    let retrainCount = 0;

    const cryptoConfig = {
      btc:{name:'Bitcoin', id:'bitcoin', color:'#f7931a', seed:45000},
      eth:{name:'Ethereum', id:'ethereum', color:'#627eea', seed:2400},
      ada:{name:'Cardano', id:'cardano', color:'#0033ad', seed:0.6},
      sol:{name:'Solana', id:'solana', color:'#9945ff', seed:70},
      hbar:{name:'Hedera', id:'hedera-hashgraph', color:'#00b4aa', seed:0.12},
      algo:{name:'Algorand', id:'algorand', color:'#000000', seed:0.14},
      xrp:{name:'XRP', id:'ripple', color:'#00aae4', seed:0.65},
      xlm:{name:'Stellar', id:'stellar', color:'#7c4dff', seed:0.13}
    };

    // ------------------------ Utils ------------------------
    function log(m){const d=document.getElementById('log');const t=new Date().toLocaleTimeString();d.textContent+=`[${t}] ${m}\n`;d.scrollTop=d.scrollHeight;}
    function setStatus(m){document.getElementById('status').textContent=m;}
    function tsSplit(arr, frac=0.8){const n=arr.length,cut=Math.floor(n*frac);return [arr.slice(0,cut), arr.slice(cut)];}
    function mae(y,yh){let s=0;for(let i=0;i<y.length;i++)s+=Math.abs(y[i]-yh[i]);return s/y.length;}
    function mape(y,yh){let s=0;for(let i=0;i<y.length;i++){const denom=Math.max(1e-9,Math.abs(y[i]));s+=Math.abs((y[i]-yh[i])/denom);}return s/y.length*100;}
    function smape(y,yh){let s=0;for(let i=0;i<y.length;i++)s+=Math.abs(yh[i]-y[i])/((Math.abs(y[i])+Math.abs(yh[i]))/2);return s/y.length*100;}
    function to2d(a){return tf.tensor2d(a,[a.length,a[0].length]);}
    function to3d(samples, L){const seq=samples.map(row=>row.slice(0,L).map(v=>[v]));return tf.tensor3d(seq,[seq.length,L,1]);}
    function formatPrice(v){return currentCrypto==='btc' ? '$'+Math.round(v) : '$'+v.toFixed(3);}

    // results table helpers
    function writeResultsRow(name, maePrice, mapePct, smapePct) {
      const tb = document.querySelector('#resultsTable tbody');
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td style="text-align:left">${name}</td>
        <td>${formatPrice(maePrice)}</td>
        <td>${mapePct.toFixed(2)}</td>
        <td>${smapePct.toFixed(2)}</td>`;
      tb.appendChild(tr);
    }
    function clearResultsTable() {
      const tb = document.querySelector('#resultsTable tbody');
      tb.innerHTML = '';
    }

    // ------------------------ UI basics ------------------------
    function updateCrypto(){
      currentCrypto = document.getElementById('cryptoType').value;
      const cfg = cryptoConfig[currentCrypto];
      log(`Switched to ${cfg.name}`);
      resetPipeline(true);
    }

    function resetPipeline(clearChart=false){
      rawData=[]; features=null; trainedModel=null;
      document.getElementById('btnFeat').disabled=true;
      document.getElementById('btnTrain').disabled=true;
      document.getElementById('btnUpdate').disabled=true;
      document.getElementById('btnCompare').disabled=true;
      document.getElementById('btnPred').disabled=true;
      document.getElementById('smape').textContent='-';
      document.getElementById('mae').textContent='-';
      clearResultsTable();
      if(clearChart && priceChart){priceChart.destroy();priceChart=null;}
      setStatus('Select an asset, load data, engineer features.');
      retrainCount = 0;
    }

    // ------------------------ Data ------------------------
    async function fetchRealData(){
      const cfg=cryptoConfig[currentCrypto];
      const days=document.getElementById('dataPeriod').value;
      log(`Fetching real ${cfg.name} data for ${days} days`);
      setStatus(`Loading live market data for ${cfg.name}`);
      try{
        const url=`https://api.coingecko.com/api/v3/coins/${cfg.id}/market_chart?vs_currency=usd&days=${days}&interval=${days<=30?'hourly':'daily'}`;
        const r=await fetch(url);
        if(!r.ok) throw new Error(`API ${r.status}`);
        const data=await r.json();
        rawData = data.prices.map(([ts,price])=>({
          date:new Date(ts),
          price:price,
          volume:(data.total_volumes.find(v=>v[0]===ts)||[0,0])[1]
        }));
        log(`Loaded ${rawData.length} points`);
        drawChart();
        document.getElementById('btnFeat').disabled=false;
        setStatus(`Live data ready. Engineer features next.`);
      }catch(e){
        log(`Error fetching API. Falling back to sample. ${e.message}`);
        generateData();
      }
    }

    function generateData(){
      const cfg=cryptoConfig[currentCrypto];
      resetPipeline(true);
      log(`Generating synthetic ${cfg.name} series`);
      const n=365;
      let price=cfg.seed;
      const out=[];
      for(let i=0;i<n;i++){
        const trend=Math.sin(i/28)*0.015;
        const noise=(Math.random()-0.5)*0.05;
        price = Math.max(0.01, price*(1+trend+noise));
        out.push({date:new Date(Date.now()-(n-i)*86400000), price});
      }
      rawData=out;
      drawChart();
      document.getElementById('btnFeat').disabled=false;
      setStatus(`Sample data ready. Engineer features next.`);
    }

    // ------------------------ Chart ------------------------
    function drawChart(){
      const ctx=document.getElementById('priceChart').getContext('2d');
      const cfg=cryptoConfig[currentCrypto];
      if(priceChart) priceChart.destroy();
      priceChart=new Chart(ctx,{
        type:'line',
        data:{
          labels:rawData.map(d=>d.date.toLocaleDateString()),
          datasets:[{label:`${cfg.name} price`,data:rawData.map(d=>d.price),borderColor:cfg.color,backgroundColor:cfg.color+'20',borderWidth:2,fill:true,pointRadius:0}]
        },
        options:{
          responsive:true,maintainAspectRatio:false,
          plugins:{legend:{labels:{color:'#fff'}}},
          scales:{x:{ticks:{color:'#fff',maxTicksLimit:8}},y:{ticks:{color:'#fff',callback:(v)=>'$'+(currentCrypto==='btc'?Math.round(v):Number(v).toFixed(3))}}}
        }
      });
    }

    // ------------------------ Features ------------------------
    function engineerFeatures(){
      const prices = rawData.map(d=>d.price);
      const dates  = rawData.map(d=>d.date);

      // log returns
      const logret = prices.map((p,i)=> i===0?0:Math.log(p/prices[i-1]));

      // rolling stats for normalization
      const W = 14;
      const rollMean=[], rollStd=[];
      for(let i=0;i<prices.length;i++){
        const s=Math.max(0,i-W+1);
        const seg=prices.slice(s,i+1);
        const m=seg.reduce((a,b)=>a+b,0)/seg.length;
        const v=seg.reduce((a,b)=>a+(b-m)*(b-m),0)/seg.length;
        rollMean.push(m);
        rollStd.push(Math.sqrt(v)+1e-8);
      }

      // windowed features
      const L = 7;
      const X=[], y=[], idx=[];
      for(let i=L;i<prices.length-1;i++){
        const seq = logret.slice(i-L+1,i+1);
        const normPrice = (prices[i]-rollMean[i])/rollStd[i];
        const up = Math.max(0, prices[i]-prices[i-1]);
        const down = Math.max(0, prices[i-1]-prices[i])+1e-8;
        const rsiLite = up/(up+down);

        const row = [...seq, normPrice, rsiLite];
        X.push(row);
        y.push((prices[i+1]-rollMean[i])/rollStd[i]);
        idx.push(i);
      }

      features = { X, y, idx, rollMean, rollStd, prices, dates, L };
      log(`Engineered ${X.length} sequences with window L=${L}`);
      document.getElementById('btnTrain').disabled=false;
      document.getElementById('btnCompare').disabled=false;
      setStatus(`Features ready. Choose model and train.`);
    }

    // ------------------------ Training and comparison ------------------------
    async function trainModel(){
      if(!features){log('No features. Click Engineer features.');return;}
      const {X,y,idx,rollMean,rollStd,prices,L} = features;

      const [Xtr,Xte] = tsSplit(X,0.8);
      const [ytr,yte] = tsSplit(y,0.8);
      if(Xte.length<5){log('Not enough test points. Load more data.');return;}

      // baseline in normalized space
      const baseNorm = Xte.map(row => row[row.length-2]);
      const baseSMAPE = smape(yte, baseNorm);

      const modelType = document.getElementById('modelType').value;
      let model;

      if(modelType==='linear'){
        model = tf.sequential({layers:[tf.layers.dense({inputShape:[Xtr[0].length],units:1})]});
        model.compile({optimizer:tf.train.adam(0.05),loss:'meanSquaredError'});
        const trainX = to2d(Xtr), trainY = tf.tensor2d(ytr,[ytr.length,1]);
        await model.fit(trainX, trainY, {epochs:40,batchSize:16,verbose:0,validationSplit:0.1});
        trainX.dispose(); trainY.dispose();
      } else if(modelType==='lstm'){
        const trainX3 = to3d(Xtr,L);
        const trainY = tf.tensor2d(ytr,[ytr.length,1]);
        model = tf.sequential({
          layers:[
            tf.layers.lstm({inputShape:[L,1],units:32,returnSequences:false}),
            tf.layers.dense({units:16,activation:'relu'}),
            tf.layers.dense({units:1})
          ]
        });
        model.compile({optimizer:tf.train.adam(0.005),loss:'meanSquaredError'});
        await model.fit(trainX3, trainY, {epochs:40,batchSize:16,verbose:0,validationSplit:0.1});
        trainX3.dispose(); trainY.dispose();
      } else {
        model = tf.sequential({
          layers:[
            tf.layers.dense({inputShape:[Xtr[0].length],units:32,activation:'relu'}),
            tf.layers.dense({units:16,activation:'relu'}),
            tf.layers.dense({units:1})
          ]
        });
        model.compile({optimizer:tf.train.adam(0.01),loss:'meanSquaredError'});
        const trainX = to2d(Xtr), trainY = tf.tensor2d(ytr,[ytr.length,1]);
        await model.fit(trainX, trainY, {epochs:40,batchSize:16,verbose:0,validationSplit:0.1});
        trainX.dispose(); trainY.dispose();
      }

      // predictions in normalized space
      let predArr;
      if(modelType==='lstm'){
        const testX3 = to3d(Xte,L);
        const yhat = await model.predict(testX3).array();
        predArr = yhat.map(v=>v[0]);
        testX3.dispose();
      } else {
        const testX = to2d(Xte);
        const yhat = await model.predict(testX).array();
        predArr = yhat.map(v=>v[0]);
        testX.dispose();
      }

      // metrics in normalized space
      const modelSMAPE = smape(yte, predArr);

      // denormalize to price units for MAE and MAPE
      const start = idx.length - Xte.length;
      const denormTrue = [], denormPred = [], denormBase = [];
      for (let i = 0; i < Xte.length; i++) {
        const pos = idx[start + i];
        const mean = rollMean[pos], sd = rollStd[pos];
        denormTrue.push(yte[i]*sd + mean);
        denormPred.push(predArr[i]*sd + mean);
        const baseP = baseNorm[i]*sd + mean;
        denormBase.push(baseP);
      }
      const modelMAE_price = mae(denormTrue, denormPred);
      const modelMAPE_price = mape(denormTrue, denormPred);
      const baseMAE_price = mae(denormTrue, denormBase);
      const baseMAPE_price = mape(denormTrue, denormBase);

      // tiles
      document.getElementById('smape').textContent = modelSMAPE.toFixed(2) + '%';
      document.getElementById('mae').textContent   = formatPrice(modelMAE_price);

      // results table
      if (retrainCount === 0) {
        clearResultsTable();
        writeResultsRow('Baseline (naive next=now)', baseMAE_price, baseMAPE_price, baseSMAPE);
      }
      writeResultsRow(modelType.toUpperCase(), modelMAE_price, modelMAPE_price, modelSMAPE);

      log(`Baseline  MAE ${formatPrice(baseMAE_price)}  MAPE ${baseMAPE_price.toFixed(2)}%  SMAPE ${baseSMAPE.toFixed(2)}%`);
      log(`Model     MAE ${formatPrice(modelMAE_price)}  MAPE ${modelMAPE_price.toFixed(2)}%  SMAPE ${modelSMAPE.toFixed(2)}%`);

      trainedModel = model;
      localStorage.setItem('modelType', modelType);
      retrainCount += 1;
      document.getElementById('btnPred').disabled=false;
      document.getElementById('btnUpdate').disabled=false;
      setStatus('Model trained. You can update or compare all.');
    }

    async function compareAll(){
      if (!features) { log('No features yet. Click Engineer features.'); return; }
      clearResultsTable();
      retrainCount = 0;

      const sel = document.getElementById('modelType');
      const original = sel.value;

      const models = ['linear','neural','lstm'];
      for (const m of models) {
        sel.value = m;
        log(`Comparing ${m.toUpperCase()}...`);
        await trainModel();
      }
      sel.value = original;
    }

    // ------------------------ Predict next step ------------------------
    function makePrediction(){
      if(!trainedModel || !features) return;
      const {X,idx,rollMean,rollStd,prices,L} = features;
      const lastX = X[X.length-1];
      const modelType = document.getElementById('modelType').value;
      let yhatTensor;

      if(modelType==='lstm'){
        const inp = to3d([lastX], L);
        yhatTensor = trainedModel.predict(inp);
        yhatTensor.data().then(v=>{
          const norm = v[0];
          const i = idx[idx.length-1];
          const pred = norm*rollStd[i] + rollMean[i];
          const curr = prices[i];
          const chg = (pred/curr - 1)*100;
          log(`Current ${formatPrice(curr)}  Predicted next ${formatPrice(pred)}  (${chg>=0?'+':''}${chg.toFixed(2)}%)`);
          setStatus(`Next step prediction: ${formatPrice(pred)}  (${chg>=0?'+':''}${chg.toFixed(2)}%)`);
        }).finally(()=>yhatTensor.dispose());
      } else {
        const inp = to2d([lastX]);
        yhatTensor = trainedModel.predict(inp);
        yhatTensor.data().then(v=>{
          const norm = v[0];
          const i = idx[idx.length-1];
          const pred = norm*rollStd[i] + rollMean[i];
          const curr = prices[i];
          const chg = (pred/curr - 1)*100;
          log(`Current ${formatPrice(curr)}  Predicted next ${formatPrice(pred)}  (${chg>=0?'+':''}${chg.toFixed(2)}%)`);
          setStatus(`Next step prediction: ${formatPrice(pred)}  (${chg>=0?'+':''}${chg.toFixed(2)}%)`);
        }).finally(()=>yhatTensor.dispose());
      }
    }

    // ------------------------ Init ------------------------
    (function init(){
      const saved = localStorage.getItem('modelType');
      if(saved){document.getElementById('modelType').value=saved;}
      log('Initialized. Load data to begin.');
    })();
  </script>
</body>
</html>
