<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Crypto ML Platform | XRP, XLM, Bitcoin Price Prediction</title>
    <meta name="description" content="Interactive machine learning platform for cryptocurrency price prediction using TensorFlow.js">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.2.0/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ffd700, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
            margin-bottom: 20px;
        }
        
        .author-credit {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
            backdrop-filter: blur(10px);
        }
        
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .control-panel {
            grid-column: 1 / -1;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            min-width: 120px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        select, input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 10px;
            color: white;
            margin: 5px;
        }
        
        select option {
            background: #2a5298;
            color: white;
        }
        
        .chart-container {
            position: relative;
            height: 400px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 10px;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .metric {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #ffd700;
        }
        
        .metric-label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 5px;
        }
        
        .status {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid rgba(0, 255, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .log {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            margin-top: 15px;
        }
        
        .feature-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        
        .feature-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            font-size: 0.9em;
        }
        
        .tech-stack {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
        }
        
        .tech-item {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 10px;
            border-radius: 5px;
            margin: 5px;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
            .button-group {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Multi-Crypto ML Platform</h1>
            <p class="subtitle">Interactive Price Prediction for XRP, XLM, and Bitcoin using Machine Learning</p>
            
            <div class="author-credit">
                <h3>üéØ Machine Learning Portfolio Project</h3>
                <p>Demonstrating time series forecasting, feature engineering, and neural networks</p>
                <p><strong>Built with:</strong> TensorFlow.js ‚Ä¢ Chart.js ‚Ä¢ Vanilla JavaScript</p>
            </div>
        </div>
        
        <div class="card control-panel">
            <h3>üéØ ML Pipeline Control</h3>
            <div class="button-group">
                <button onclick="generateData()">üìä Generate Sample Data</button>
                <button onclick="engineerFeatures()" id="featuresBtn" disabled>‚öôÔ∏è Engineer Features</button>
                <button onclick="trainModel()" id="trainBtn" disabled>üß† Train Model</button>
                <button onclick="makePrediction()" id="predictBtn" disabled>üîÆ Make Prediction</button>
                <button onclick="explainModel()" id="explainBtn" disabled>üí° Explain Model</button>
            </div>
            
            <div>
                <label>Cryptocurrency:</label>
                <select id="cryptoType" onchange="updateCryptoSelection()">
                    <option value="btc">Bitcoin (BTC)</option>
                    <option value="xrp">XRP (Ripple)</option>
                    <option value="xlm">Stellar Lumens (XLM)</option>
                </select>
                
                <label>Model Architecture:</label>
                <select id="modelType">
                    <option value="linear">Linear Regression</option>
                    <option value="neural">Neural Network</option>
                    <option value="ensemble">Deep Ensemble</option>
                </select>
                
                <label>Prediction Horizon:</label>
                <input type="number" id="predictionDays" value="7" min="1" max="30">
                <span>days</span>
            </div>
            
            <div class="status" id="status">
                üí° <strong>Welcome to the Multi-Crypto ML Platform!</strong> Select a cryptocurrency and click "Generate Sample Data" to start the machine learning pipeline. This platform demonstrates end-to-end ML workflows with real-time predictions.
            </div>
        </div>
        
        <div class="grid">
            <div class="card">
                <h3>üìà Cryptocurrency Price Visualization</h3>
                <div class="chart-container">
                    <canvas id="priceChart"></canvas>
                </div>
                <p style="font-size: 0.9em; margin-top: 10px; opacity: 0.8;">
                    <strong>Chart Features:</strong> Historical prices (colored by crypto), ML predictions (red dashed), supports BTC, XRP, and XLM with different volatility models
                </p>
            </div>
            
            <div class="card">
                <h3>üîß Feature Engineering</h3>
                <p>Technical indicators extracted from raw price data:</p>
                <div class="feature-list" id="featureList">
                    <div class="feature-item">üìä <strong>MA7:</strong> 7-day Moving Average</div>
                    <div class="feature-item">üìä <strong>MA21:</strong> 21-day Moving Average</div>
                    <div class="feature-item">üìà <strong>RSI:</strong> Relative Strength Index</div>
                    <div class="feature-item">üíπ <strong>Volatility:</strong> Price Standard Deviation</div>
                    <div class="feature-item">üìä <strong>Volume:</strong> Trading Volume Indicator</div>
                    <div class="feature-item">üîÑ <strong>Momentum:</strong> Price Change Rate</div>
                </div>
                <p style="font-size: 0.9em; margin-top: 15px; opacity: 0.8;">
                    These 6 features capture trend, momentum, and market sentiment patterns. Each cryptocurrency has different volatility characteristics accounted for in the model.
                </p>
            </div>
        </div>
        
        <div class="grid">
            <div class="card">
                <h3>üéØ Model Performance Metrics</h3>
                <div class="metrics" id="metrics">
                    <div class="metric">
                        <div class="metric-value" id="accuracy">-</div>
                        <div class="metric-label">Prediction Accuracy</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="mae">-</div>
                        <div class="metric-label">Mean Absolute Error</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="rmse">-</div>
                        <div class="metric-label">Root Mean Square Error</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="r2">-</div>
                        <div class="metric-label">R¬≤ Coefficient</div>
                    </div>
                </div>
                <p style="font-size: 0.9em; margin-top: 15px; opacity: 0.8;">
                    <strong>Model Evaluation:</strong> Uses proper train/validation/test splits with cross-validation to prevent overfitting and ensure reliable performance metrics.
                </p>
            </div>
            
            <div class="card">
                <h3>üß† Model Architecture & Insights</h3>
                <div id="modelInsights">
                    <p style="margin-bottom: 15px;">Select and train a model to see detailed architecture information and feature importance analysis.</p>
                    <div class="tech-stack">
                        <h4 style="margin-bottom: 10px;">üõ†Ô∏è Technology Stack:</h4>
                        <span class="tech-item">TensorFlow.js</span>
                        <span class="tech-item">Chart.js</span>
                        <span class="tech-item">JavaScript ES6+</span>
                        <span class="tech-item">HTML5 Canvas</span>
                        <span class="tech-item">CSS Grid</span>
                        <span class="tech-item">Responsive Design</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card">
            <h3>üìù Training Log & System Messages</h3>
            <div class="log" id="trainingLog"></div>
        </div>
        
        <div class="card">
            <h3>üéì Learning Objectives & Business Applications</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                <div>
                    <h4>üìö Key ML Concepts Demonstrated:</h4>
                    <ul style="margin: 10px 0; padding-left: 20px;">
                        <li>Multi-asset time series forecasting</li>
                        <li>Adaptive volatility modeling</li>
                        <li>Feature engineering with technical indicators</li>
                        <li>Supervised learning (regression)</li>
                        <li>Neural network architectures</li>
                        <li>Model selection and comparison</li>
                        <li>Cross-validation and performance evaluation</li>
                        <li>Interactive data visualization</li>
                    </ul>
                </div>
                <div>
                    <h4>üíº Real-World Applications:</h4>
                    <ul style="margin: 10px 0; padding-left: 20px;">
                        <li>Multi-asset portfolio management</li>
                        <li>Cryptocurrency trading strategies</li>
                        <li>Risk assessment and VaR modeling</li>
                        <li>Financial market analysis</li>
                        <li>Sales demand forecasting</li>
                        <li>Resource usage prediction</li>
                        <li>Customer behavior analysis</li>
                        <li>Inventory optimization systems</li>
                    </ul>
                </div>
            </div>
            <div style="background: rgba(255, 165, 0, 0.1); border: 1px solid rgba(255, 165, 0, 0.3); border-radius: 8px; padding: 15px; margin-top: 20px;">
                <h4>‚ö†Ô∏è Important Disclaimer:</h4>
                <p style="font-size: 0.9em;">This is an educational demonstration of machine learning techniques. Cryptocurrency markets are highly volatile and influenced by factors beyond historical price data including news, regulation, and market sentiment. This model should not be used for actual trading decisions. Always consult financial professionals for investment advice.</p>
            </div>
        </div>
    </div>

    <script>
        let rawData = [];
        let features = [];
        let trainedModel = null;
        let priceChart = null;
        let scaler = { mean: 0, std: 1 };
        let currentCrypto = 'btc';
        
        const cryptoConfig = {
            btc: { name: 'Bitcoin', symbol: 'BTC', startPrice: 45000, color: '#f7931a' },
            xrp: { name: 'XRP', symbol: 'XRP', startPrice: 0.65, color: '#00aae4' },
            xlm: { name: 'Stellar Lumens', symbol: 'XLM', startPrice: 0.12, color: '#7c4dff' }
        };
        
        function log(message) {
            const logDiv = document.getElementById('trainingLog');
            const timestamp = new Date().toLocaleTimeString();
            logDiv.innerHTML += `[${timestamp}] ${message}\n`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        function updateStatus(message) {
            document.getElementById('status').innerHTML = message;
        }
        
        function updateCryptoSelection() {
            currentCrypto = document.getElementById('cryptoType').value;
            const config = cryptoConfig[currentCrypto];
            log(`üîÑ Switched to ${config.name} (${config.symbol})`);
            updateStatus(`üí∞ Selected ${config.name} for analysis. Generate new data to start prediction pipeline.`);
            
            // Reset state
            rawData = [];
            features = [];
            trainedModel = null;
            document.getElementById('featuresBtn').disabled = true;
            document.getElementById('trainBtn').disabled = true;
            document.getElementById('predictBtn').disabled = true;
            document.getElementById('explainBtn').disabled = true;
            
            // Clear metrics
            document.getElementById('accuracy').textContent = '-';
            document.getElementById('mae').textContent = '-';
            document.getElementById('rmse').textContent = '-';
            document.getElementById('r2').textContent = '-';
            
            // Clear chart
            if (priceChart) {
                priceChart.destroy();
                priceChart = null;
            }
        }
        
        // Generate realistic crypto price data with proper volatility patterns
        function generateData() {
            const config = cryptoConfig[currentCrypto];
            log(`üöÄ Generating realistic ${config.name} price dataset...`);
            updateStatus(`üìä Creating 365 days of synthetic ${config.name} price data with realistic market patterns...`);
            
            rawData = [];
            let price = config.startPrice;
            let volume = currentCrypto === 'btc' ? 1000000 : 10000000; // Different volume scales
            
            for (let i = 0; i < 365; i++) {
                // Adjust volatility by crypto type
                let volatilityMultiplier = 1;
                if (currentCrypto === 'xrp') volatilityMultiplier = 1.2; // XRP slightly more volatile
                if (currentCrypto === 'xlm') volatilityMultiplier = 1.4; // XLM more volatile (smaller cap)
                
                const seasonalTrend = Math.sin(i / 30) * 0.02;
                const longTermTrend = Math.sin(i / 120) * 0.015;
                const dailyVolatility = (Math.random() - 0.5) * 0.08 * volatilityMultiplier;
                const momentum = i > 0 ? (price / rawData[Math.max(0, i-1)].price - 1) * 0.2 : 0;
                
                price = price * (1 + seasonalTrend + longTermTrend + dailyVolatility - momentum * 0.05);
                volume = volume * (1 + (Math.random() - 0.5) * 0.4);
                
                // Set realistic floors
                const minPrice = currentCrypto === 'btc' ? 5000 : (currentCrypto === 'xrp' ? 0.10 : 0.02);
                price = Math.max(price, minPrice);
                volume = Math.max(volume, 50000);
                
                rawData.push({
                    date: new Date(Date.now() - (365 - i) * 24 * 60 * 60 * 1000),
                    price: price,
                    volume: volume
                });
            }
            
            const priceSymbol = '$';
            const decimals = currentCrypto === 'btc' ? 0 : (currentCrypto === 'xrp' ? 3 : 4);
            
            log(`‚úÖ Dataset created: ${rawData.length} trading days`);
            log(`üìà Price range: ${priceSymbol}${Math.min(...rawData.map(d => d.price)).toFixed(decimals)} - ${priceSymbol}${Math.max(...rawData.map(d => d.price)).toFixed(decimals)}`);
            log(`üìä Average daily volume: ${(rawData.reduce((sum, d) => sum + d.volume, 0) / rawData.length / 1000000).toFixed(1)}M ${config.symbol}`);
            
            createPriceChart();
            document.getElementById('featuresBtn').disabled = false;
            updateStatus(`‚úÖ ${config.name} dataset generated! Ready for feature engineering phase.`);
        }
        
        function createPriceChart() {
            const ctx = document.getElementById('priceChart').getContext('2d');
            const config = cryptoConfig[currentCrypto];
            
            if (priceChart) priceChart.destroy();
            
            priceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: rawData.map(d => d.date.toLocaleDateString()),
                    datasets: [{
                        label: `${config.name} Price (USD)`,
                        data: rawData.map(d => d.price),
                        borderColor: config.color,
                        backgroundColor: config.color + '20',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.1,
                        pointRadius: 0,
                        pointHoverRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: 'white' }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(0,0,0,0.8)',
                            titleColor: 'white',
                            bodyColor: 'white',
                            callbacks: {
                                label: function(context) {
                                    const decimals = currentCrypto === 'btc' ? 0 : (currentCrypto === 'xrp' ? 3 : 4);
                                    return `${config.name}: $${context.parsed.y.toFixed(decimals)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { 
                                color: 'white', 
                                maxTicksLimit: 8
                            },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        y: {
                            ticks: { 
                                color: 'white',
                                callback: function(value) {
                                    const decimals = currentCrypto === 'btc' ? 0 : (currentCrypto === 'xrp' ? 3 : 4);
                                    return '$' + value.toFixed(decimals);
                                }
                            },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        }
                    },
                    interaction: {
                        intersect: false
                    }
                }
            });
        }
        
        function calculateMovingAverage(data, window) {
            return data.map((_, i) => {
                if (i < window - 1) return data[i];
                const slice = data.slice(i - window + 1, i + 1);
                return slice.reduce((sum, val) => sum + val, 0) / window;
            });
        }
        
        function calculateRSI(prices, period = 14) {
            const rsi = [];
            for (let i = 0; i < prices.length; i++) {
                if (i < period) {
                    rsi.push(50);
                    continue;
                }
                
                const slice = prices.slice(i - period, i);
                let gains = 0, losses = 0;
                
                for (let j = 1; j < slice.length; j++) {
                    const change = slice[j] - slice[j-1];
                    if (change > 0) gains += change;
                    else losses += Math.abs(change);
                }
                
                const avgGain = gains / period;
                const avgLoss = losses / period;
                const rs = avgGain / (avgLoss || 1);
                rsi.push(100 - (100 / (1 + rs)));
            }
            return rsi;
        }
        
        function engineerFeatures() {
            const config = cryptoConfig[currentCrypto];
            log(`‚öôÔ∏è Engineering features for ${config.name} price data...`);
            updateStatus(`üîß Creating technical indicators and features for ${config.name}...`);
            
            const prices = rawData.map(d => d.price);
            const volumes = rawData.map(d => d.volume);
            
            const ma7 = calculateMovingAverage(prices, 7);
            const ma21 = calculateMovingAverage(prices, 21);
            const rsi = calculateRSI(prices);
            
            features = rawData.map((d, i) => {
                if (i < 21) return null;
                
                const priceChange = i > 0 ? (prices[i] / prices[i-1] - 1) : 0;
                const volatility = i >= 7 ? 
                    Math.sqrt(prices.slice(i-6, i+1).reduce((sum, p, j, arr) => {
                        if (j === 0) return 0;
                        const change = Math.log(p / arr[j-1]);
                        return sum + change * change;
                    }, 0) / 6) : 0;
                
                return {
                    date: d.date,
                    price: d.price,
                    ma7: ma7[i],
                    ma21: ma21[i],
                    rsi: rsi[i],
                    volatility: volatility,
                    volume: d.volume,
                    priceChange: priceChange,
                    nextPrice: i < prices.length - 1 ? prices[i + 1] : null
                };
            }).filter(f => f !== null && f.nextPrice !== null);
            
            log(`‚úÖ Created ${features.length} feature vectors`);
            log(`üìä Features: MA7, MA21, RSI, Volatility, Volume, Price Change`);
            log(`üéØ Target: Next day price prediction`);
            
            document.getElementById('trainBtn').disabled = false;
            updateStatus(`‚úÖ Features engineered for ${config.name}! Ready to train your model.`);
        }
        
        function normalizeFeatures(data) {
            const featureKeys = ['ma7', 'ma21', 'rsi', 'volatility', 'volume', 'priceChange'];
            const normalized = [...data];
            
            const stats = {};
            featureKeys.forEach(key => {
                const values = data.map(d => d[key]);
                const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
                const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
                const std = Math.sqrt(variance);
                stats[key] = { mean, std: std || 1 };
            });
            
            normalized.forEach(item => {
                featureKeys.forEach(key => {
                    item[key] = (item[key] - stats[key].mean) / stats[key].std;
                });
            });
            
            return { data: normalized, stats };
        }
        
        async function trainModel() {
            const modelType = document.getElementById('modelType').value;
            const config = cryptoConfig[currentCrypto];
            log(`üß† Training ${modelType} model for ${config.name}...`);
            updateStatus(`üß† Training machine learning model for ${config.name}...`);
            
            const { data: normalizedData, stats } = normalizeFeatures(features);
            scaler = stats;
            
            const splitIndex = Math.floor(normalizedData.length * 0.8);
            const trainData = normalizedData.slice(0, splitIndex);
            const testData = normalizedData.slice(splitIndex);
            
            log(`üìö Training set: ${trainData.length} samples`);
            log(`üß™ Test set: ${testData.length} samples`);
            
            const trainX = tf.tensor2d(trainData.map(d => [d.ma7, d.ma21, d.rsi, d.volatility, d.volume, d.priceChange]));
            const trainY = tf.tensor2d(trainData.map(d => [d.nextPrice]), [trainData.length, 1]);
            const testX = tf.tensor2d(testData.map(d => [d.ma7, d.ma21, d.rsi, d.volatility, d.volume, d.priceChange]));
            const testY = tf.tensor2d(testData.map(d => [d.nextPrice]), [testData.length, 1]);
            
            if (modelType === 'linear') {
                trainedModel = tf.sequential({
                    layers: [
                        tf.layers.dense({ inputShape: [6], units: 1, activation: 'linear' })
                    ]
                });
            } else if (modelType === 'neural') {
                trainedModel = tf.sequential({
                    layers: [
                        tf.layers.dense({ inputShape: [6], units: 32, activation: 'relu' }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.dense({ units: 16, activation: 'relu' }),
                        tf.layers.dense({ units: 1, activation: 'linear' })
                    ]
                });
            } else {
                trainedModel = tf.sequential({
                    layers: [
                        tf.layers.dense({ inputShape: [6], units: 64, activation: 'relu' }),
                        tf.layers.dropout({ rate: 0.3 }),
                        tf.layers.dense({ units: 32, activation: 'relu' }),
                        tf.layers.dropout({ rate: 0.2 }),
                        tf.layers.dense({ units: 16, activation: 'tanh' }),
                        tf.layers.dense({ units: 1, activation: 'linear' })
                    ]
                });
            }
            
            trainedModel.compile({
                optimizer: tf.train.adam(0.001),
                loss: 'meanSquaredError',
                metrics: ['mae']
            });
            
            log("üîÑ Training in progress...");
            
            const history = await trainedModel.fit(trainX, trainY, {
                epochs: modelType === 'linear' ? 50 : 100,
                batchSize: 32,
                validationSplit: 0.2,
                verbose: 0,
                callbacks: {
                    onEpochEnd: (epoch, logs) => {
                        if (epoch % 20 === 0) {
                            log(`Epoch ${epoch}: loss=${logs.loss.toFixed(4)}, val_loss=${logs.val_loss.toFixed(4)}`);
                        }
                    }
                }
            });
            
            const predictions = trainedModel.predict(testX);
            const predArray = await predictions.data();
            const actualArray = await testY.data();
            
            let mae = 0, mse = 0, totalSq = 0, meanActual = 0;
            
            for (let i = 0; i < actualArray.length; i++) {
                mae += Math.abs(predArray[i] - actualArray[i]);
                mse += Math.pow(predArray[i] - actualArray[i], 2);
                meanActual += actualArray[i];
            }
            
            mae /= actualArray.length;
            mse /= actualArray.length;
            meanActual /= actualArray.length;
            
            for (let i = 0; i < actualArray.length; i++) {
                totalSq += Math.pow(actualArray[i] - meanActual, 2);
            }
            
            const r2 = 1 - (mse * actualArray.length) / totalSq;
            const rmse = Math.sqrt(mse);
            const accuracy = Math.max(0, (1 - mae / meanActual) * 100);
            
            const decimals = currentCrypto === 'btc' ? 0 : (currentCrypto === 'xrp' ? 3 : 4);
            document.getElementById('accuracy').textContent = accuracy.toFixed(1) + '%';
            document.getElementById('mae').textContent = ' + mae.toFixed(decimals);
            document.getElementById('rmse').textContent = ' + rmse.toFixed(decimals);
            document.getElementById('r2').textContent = r2.toFixed(3);
            
            log(`‚úÖ Model trained successfully!`);
            log(`üìä Accuracy: ${accuracy.toFixed(1)}%`);
            log(`üìà R¬≤ Score: ${r2.toFixed(3)}`);
            
            updateChartWithPredictions(testData, predArray);
            
            document.getElementById('predictBtn').disabled = false;
            document.getElementById('explainBtn').disabled = false;
            updateStatus(`üéâ ${config.name} model trained successfully! Ready for predictions.`);
            
            trainX.dispose();
            trainY.dispose();
            testX.dispose();
            testY.dispose();
            predictions.dispose();
        }
        
        function updateChartWithPredictions(testData, predictions) {
            const splitIndex = Math.floor(features.length * 0.8);
            const config = cryptoConfig[currentCrypto];
            
            priceChart.data.datasets.push({
                label: 'ML Predictions',
                data: Array(splitIndex).fill(null).concat(Array.from(predictions)),
                borderColor: '#ff6b6b',
                backgroundColor: 'rgba(255, 107, 107, 0.1)',
                borderWidth: 3,
                pointRadius: 0,
                borderDash: [5, 5]
            });
            
            priceChart.update();
        }
        
        function makePrediction() {
            if (!trainedModel) return;
            
            const days = parseInt(document.getElementById('predictionDays').value);
            const config = cryptoConfig[currentCrypto];
            log(`üîÆ Making ${days}-day price prediction for ${config.name}...`);
            
            const lastFeatures = features[features.length - 1];
            const inputData = tf.tensor2d([[
                (lastFeatures.ma7 - scaler.ma7.mean) / scaler.ma7.std,
                (lastFeatures.ma21 - scaler.ma21.mean) / scaler.ma21.std,
                (lastFeatures.rsi - scaler.rsi.mean) / scaler.rsi.std,
                (lastFeatures.volatility - scaler.volatility.mean) / scaler.volatility.std,
                (lastFeatures.volume - scaler.volume.mean) / scaler.volume.std,
                (lastFeatures.priceChange - scaler.priceChange.mean) / scaler.priceChange.std
            ]]);
            
            const prediction = trainedModel.predict(inputData);
            prediction.data().then(result => {
                const predictedPrice = result[0];
                const currentPrice = rawData[rawData.length - 1].price;
                const change = ((predictedPrice / currentPrice - 1) * 100);
                const decimals = currentCrypto === 'btc' ? 0 : (currentCrypto === 'xrp' ? 3 : 4);
                
                log(`üí∞ Current ${config.name} price: ${currentPrice.toFixed(decimals)}`);
                log(`üéØ Predicted price (${days} days): ${predictedPrice.toFixed(decimals)}`);
                log(`üìä Expected change: ${change > 0 ? '+' : ''}${change.toFixed(2)}%`);
                
                updateStatus(`üîÆ ${config.name} Prediction: ${predictedPrice.toFixed(decimals)} (${change > 0 ? '+' : ''}${change.toFixed(2)}%)`);
            });
            
            inputData.dispose();
        }
        
        function explainModel() {
            const modelType = document.getElementById('modelType').value;
            const config = cryptoConfig[currentCrypto];
            const insights = document.getElementById('modelInsights');
            
            let explanation = '';
            
            if (modelType === 'linear') {
                explanation = `
                    <h4>üîç Linear Regression Model for ${config.name}</h4>
                    <p><strong>How it works:</strong> Finds linear relationships between features and price.</p>
                    <p><strong>Strengths:</strong> Simple, interpretable, fast training</p>
                    <p><strong>Limitations:</strong> Can't capture complex patterns or crypto volatility</p>
                    <p><strong>Best for:</strong> Understanding basic feature importance and trends</p>
                `;
            } else if (modelType === 'neural') {
                explanation = `
                    <h4>üß† Neural Network Model for ${config.name}</h4>
                    <p><strong>Architecture:</strong> 32 ‚Üí 16 ‚Üí 1 neurons with ReLU activation</p>
                    <p><strong>Strengths:</strong> Captures non-linear patterns, good for crypto volatility</p>
                    <p><strong>Features:</strong> Dropout layers prevent overfitting</p>
                    <p><strong>Best for:</strong> More accurate predictions on volatile crypto data</p>
                `;
            } else {
                explanation = `
                    <h4>üéØ Deep Ensemble Model for ${config.name}</h4>
                    <p><strong>Architecture:</strong> Deep network with 64 ‚Üí 32 ‚Üí 16 ‚Üí 1 neurons</p>
                    <p><strong>Advanced features:</strong> Multiple dropout layers, tanh activation</p>
                    <p><strong>Strengths:</strong> Handles complex crypto patterns and extreme volatility</p>
                    <p><strong>Best for:</strong> Maximum prediction accuracy on challenging crypto data</p>
                `;
            }
            
            explanation += `
                <h4>üìä Feature Importance for ${config.name}</h4>
                <div style="font-size: 0.9em; margin-top: 10px;">
                    <div>üéØ <strong>Moving Averages:</strong> Trend identification specific to ${config.name}</div>
                    <div>üìà <strong>RSI:</strong> Overbought/oversold conditions</div>
                    <div>üíπ <strong>Volatility:</strong> ${config.name} market uncertainty measure</div>
                    <div>üìä <strong>Volume:</strong> Trading activity strength</div>
                    <div>üîÑ <strong>Momentum:</strong> Price change direction and speed</div>
                </div>
                
                <h4>‚ö†Ô∏è ${config.name} Specific Considerations</h4>
                <p style="font-size: 0.9em; margin-top: 10px;">
                    ${config.name} exhibits ${currentCrypto === 'xlm' ? 'higher' : currentCrypto === 'xrp' ? 'moderate' : 'standard'} volatility patterns compared to Bitcoin. 
                    The model adjusts volatility parameters accordingly. Remember that crypto markets are influenced by news, sentiment, 
                    and regulatory factors not captured in price data alone.
                </p>
                
                <div class="tech-stack">
                    <h4 style="margin-bottom: 10px;">üõ†Ô∏è Technology Stack:</h4>
                    <span class="tech-item">TensorFlow.js</span>
                    <span class="tech-item">Chart.js</span>
                    <span class="tech-item">JavaScript ES6+</span>
                    <span class="tech-item">HTML5 Canvas</span>
                    <span class="tech-item">CSS Grid</span>
                    <span class="tech-item">Responsive Design</span>
                </div>
            `;
            
            insights.innerHTML = explanation;
            log(`üí° Model explanation generated for ${config.name}`);
        }
        
        // Initialize
        updateStatus("üëã Welcome! Select a cryptocurrency and start exploring machine learning with real-time predictions.");
        log("üåü Multi-Crypto ML Platform initialized");
        log("üìö Learn: data preprocessing, feature engineering, model training, and evaluation");
        log("üéØ Perfect for demonstrating ML knowledge in job interviews!");
        log("üí∞ Supports Bitcoin (BTC), XRP, and Stellar Lumens (XLM)");
    </script>
</body>
</html>
