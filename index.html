<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Multi-Crypto ML Platform | Reliable Data</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.2.0/tf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Arial,sans-serif;background:linear-gradient(135deg,#1e3c72,#2a5298);color:#fff;min-height:100vh;padding:20px}
    .container{max-width:1200px;margin:0 auto}
    .header{text-align:center;margin-bottom:24px}
    .header h1{font-size:2rem;margin-bottom:8px;background:linear-gradient(45deg,#ffd700,#ff6b6b);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
    .card{background:rgba(255,255,255,.1);backdrop-filter:blur(10px);border-radius:14px;padding:18px;border:1px solid rgba(255,255,255,.2);margin-bottom:16px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
    @media (max-width:900px){.grid{grid-template-columns:1fr}}
    .button-group{display:flex;flex-wrap:wrap;gap:8px;margin:12px 0}
    button{background:linear-gradient(45deg,#667eea,#764ba2);color:#fff;border:0;padding:10px 16px;border-radius:10px;font-weight:600;cursor:pointer;transition:transform .15s}
    button:hover{transform:translateY(-1px)}
    button:disabled{opacity:.55;cursor:not-allowed;transform:none}
    select{background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.3);border-radius:8px;color:#fff;padding:8px}
    .chart-container{position:relative;height:420px;background:rgba(255,255,255,.05);border-radius:10px;padding:10px}
    .metrics{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:10px;margin-top:10px}
    .metric{background:rgba(255,255,255,.1);border-radius:10px;padding:12px;text-align:center}
    .metric .value{font-size:1.4rem;font-weight:700;color:#ffd700}
    .log{background:rgba(0,0,0,.35);border-radius:8px;padding:12px;height:220px;overflow:auto;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:.9rem;white-space:pre-wrap}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    .status{background:rgba(0,255,0,.1);border:1px solid rgba(0,255,0,.3);border-radius:8px;padding:12px;margin-top:10px}
    .badge{position:fixed;top:14px;right:14px;background:#005a27;color:#fff;border-radius:10px;padding:8px 12px;font-weight:700;border:1px solid rgba(255,255,255,.2);font-size:0.8rem}
    table{width:100%;margin-top:10px;border-collapse:collapse}
    th,td{padding:6px}
    thead th{border-bottom:1px solid rgba(255,255,255,.3);text-align:left}
    tbody td{text-align:right}
    tbody td:first-child{text-align:left}
  </style>
</head>
<body>
  <div class="container">
    <div class="badge" id="dataSource">Multiple Sources</div>

    <div class="header">
      <h1>Multi-Crypto ML Platform</h1>
      <p>Clean data from reliable free APIs with simple fallbacks</p>
    </div>

    <div class="card">
      <h3>Controls</h3>
      <div class="button-group">
        <button id="btnReal" onclick="fetchRealData()">Load real data</button>
        <button id="btnGen" onclick="generateData()">Generate sample</button>
        <button id="btnFeat" onclick="engineerFeatures()" disabled>Engineer features</button>
        <button id="btnTrain" onclick="trainModel()" disabled>Train model</button>
        <button id="btnUpdate" onclick="trainModel()" disabled>Update model</button>
        <button id="btnCompare" onclick="compareAll()" disabled>Compare all models</button>
        <button id="btnPred" onclick="makePrediction()" disabled>Predict next</button>
      </div>
      <div class="row">
        <label>Asset</label>
        <select id="cryptoType" onchange="updateCrypto()">
          <optgroup label="Major Coins">
            <option value="btc">Bitcoin</option>
            <option value="eth">Ethereum</option>
            <option value="ada">Cardano</option>
            <option value="sol">Solana</option>
            <option value="xrp">XRP</option>
          </optgroup>
          <optgroup label="Others">
            <option value="dot">Polkadot</option>
            <option value="link">Chainlink</option>
            <option value="matic">Polygon</option>
          </optgroup>
        </select>

        <label>Period</label>
        <select id="dataPeriod">
          <option value="7">7 days</option>
          <option value="30">30 days</option>
          <option value="90">90 days</option>
          <option value="365" selected>1 year</option>
        </select>

        <label>Model</label>
        <select id="modelType">
          <option value="neural">MLP demo</option>
          <option value="linear">Linear</option>
          <option value="lstm">LSTM sequence</option>
        </select>
      </div>
      <div id="status" class="status">Select an asset and load real data to begin.</div>
    </div>

    <div class="grid">
      <div class="card">
        <h3>Price chart</h3>
        <div class="chart-container"><canvas id="priceChart"></canvas></div>
      </div>
      <div class="card">
        <h3>Metrics</h3>
        <div class="metrics">
          <div class="metric">
            <div id="smape" class="value">-</div>
            <div>SMAPE percent</div>
          </div>
          <div class="metric">
            <div id="mae" class="value">-</div>
            <div>MAE in price units</div>
          </div>
        </div>

        <table id="resultsTable">
          <thead>
            <tr>
              <th>Model</th>
              <th style="text-align:right">MAE (price)</th>
              <th style="text-align:right">MAPE %</th>
              <th style="text-align:right">SMAPE %</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>

        <div style="margin-top:10px;font-size:.95rem">
          Baseline is naive next equals now. Models compare against this simple prediction.
        </div>
      </div>
    </div>

    <div class="card">
      <h3>Log</h3>
      <div id="log" class="log"></div>
    </div>
  </div>

  <script>
    // ------------------------ State ------------------------
    let rawData = [];
    let features = null;
    let trainedModel = null;
    let priceChart = null;
    let currentCrypto = 'btc';
    let retrainCount = 0;

    const cryptoConfig = {
      btc: {name:'Bitcoin', symbol:'bitcoin', color:'#f7931a'},
      eth: {name:'Ethereum', symbol:'ethereum', color:'#627eea'},
      ada: {name:'Cardano', symbol:'cardano', color:'#0033ad'},
      sol: {name:'Solana', symbol:'solana', color:'#9945ff'},
      xrp: {name:'XRP', symbol:'ripple', color:'#00aae4'},
      dot: {name:'Polkadot', symbol:'polkadot', color:'#e6007a'},
      link: {name:'Chainlink', symbol:'chainlink', color:'#375bd2'},
      matic: {name:'Polygon', symbol:'matic-network', color:'#8247e5'}
    };

    // ------------------------ Utils ------------------------
    function log(m){const d=document.getElementById('log');const t=new Date().toLocaleTimeString();d.textContent+=`[${t}] ${m}\n`;d.scrollTop=d.scrollHeight;}
    function setStatus(m){document.getElementById('status').textContent=m;}
    function setDataSource(source){document.getElementById('dataSource').textContent=source;}
    function tsSplit(arr, frac=0.8){const n=arr.length,cut=Math.floor(n*frac);return [arr.slice(0,cut), arr.slice(cut)];}
    function mae(y,yh){let s=0;for(let i=0;i<y.length;i++)s+=Math.abs(y[i]-yh[i]);return s/y.length;}
    function mape(y,yh){let s=0;for(let i=0;i<y.length;i++){const denom=Math.max(1e-9,Math.abs(y[i]));s+=Math.abs((y[i]-yh[i])/denom);}return s/y.length*100;}
    function smape(y,yh){let s=0;for(let i=0;i<y.length;i++)s+=Math.abs(yh[i]-y[i])/((Math.abs(y[i])+Math.abs(yh[i]))/2);return s/y.length*100;}
    function to2d(a){return tf.tensor2d(a,[a.length,a[0].length]);}
    function to3d(samples, L){const seq=samples.map(row=>row.slice(0,L).map(v=>[v]));return tf.tensor3d(seq,[seq.length,L,1]);}
    function formatPrice(v){return currentCrypto==='btc' ? '$'+Math.round(v) : '$'+v.toFixed(3);}

    // results table helpers
    function writeResultsRow(name, maePrice, mapePct, smapePct) {
      const tb = document.querySelector('#resultsTable tbody');
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td style="text-align:left">${name}</td>
        <td>${formatPrice(maePrice)}</td>
        <td>${mapePct.toFixed(2)}</td>
        <td>${smapePct.toFixed(2)}</td>`;
      tb.appendChild(tr);
    }
    function clearResultsTable() {
      const tb = document.querySelector('#resultsTable tbody');
      tb.innerHTML = '';
    }

    // ------------------------ Simple Data Fetching ------------------------
    async function fetchRealData(){
      const cfg = cryptoConfig[currentCrypto];
      const days = document.getElementById('dataPeriod').value;
      log(`Loading ${cfg.name} data (${days} days)...`);
      setStatus(`Loading ${cfg.name} market data...`);

      // Try multiple free APIs in order
      const sources = [
        {
          name: 'CoinGecko',
          fetch: async () => {
            const url = `https://api.coingecko.com/api/v3/coins/${cfg.symbol}/market_chart?vs_currency=usd&days=${days}`;
            const r = await fetch(url);
            if (!r.ok) throw new Error(`Status ${r.status}`);
            const data = await r.json();
            return data.prices.map(([ts, price]) => ({
              date: new Date(ts),
              price: price
            }));
          }
        },
        {
          name: 'CoinPaprika',
          fetch: async () => {
            // Simple symbol mapping for coinpaprika
            const symbolMap = {btc:'btc-bitcoin',eth:'eth-ethereum',ada:'ada-cardano',sol:'sol-solana',xrp:'xrp-xrp'};
            const paprikaId = symbolMap[currentCrypto] || `${currentCrypto}-${cfg.name.toLowerCase()}`;
            const start = new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
            const url = `https://api.coinpaprika.com/v1/coins/${paprikaId}/ohlcv/historical?start=${start}`;
            const r = await fetch(url);
            if (!r.ok) throw new Error(`Status ${r.status}`);
            const data = await r.json();
            return data.map(item => ({
              date: new Date(item.time_close),
              price: item.close
            }));
          }
        }
      ];

      // Try each source
      for (const source of sources) {
        try {
          log(`Trying ${source.name}...`);
          const data = await source.fetch();
          if (data && data.length > 10) {
            rawData = data.sort((a, b) => a.date - b.date);
            setDataSource(source.name);
            log(`✅ Loaded ${data.length} points from ${source.name}`);
            drawChart();
            document.getElementById('btnFeat').disabled = false;
            setStatus(`Real market data loaded from ${source.name}. Ready for features.`);
            return;
          }
        } catch (e) {
          log(`${source.name} failed: ${e.message}`);
        }
      }

      // If all sources fail, fall back to sample data with clear warning
      log('⚠️ All APIs failed - using sample data for demo');
      setDataSource('Sample Data');
      generateData();
    }

    function generateData(){
      const cfg = cryptoConfig[currentCrypto];
      resetPipeline(true);
      
      // Generate realistic-looking sample data
      const n = parseInt(document.getElementById('dataPeriod').value);
      const basePrice = currentCrypto === 'btc' ? 45000 : currentCrypto === 'eth' ? 2500 : 1.0;
      let price = basePrice;
      const out = [];
      
      for(let i = 0; i < n; i++){
        const trend = Math.sin(i / 20) * 0.02;
        const noise = (Math.random() - 0.5) * 0.06;
        price = Math.max(basePrice * 0.1, price * (1 + trend + noise));
        out.push({
          date: new Date(Date.now() - (n - i) * 86400000),
          price: price
        });
      }
      
      rawData = out;
      log(`Generated ${n} sample data points for ${cfg.name}`);
      drawChart();
      document.getElementById('btnFeat').disabled = false;
      setStatus(`Sample data ready. Note: This is synthetic data for demo purposes.`);
    }

    // ------------------------ UI basics ------------------------
    function updateCrypto(){
      currentCrypto = document.getElementById('cryptoType').value;
      const cfg = cryptoConfig[currentCrypto];
      log(`Switched to ${cfg.name}`);
      resetPipeline(true);
    }

    function resetPipeline(clearChart=false){
      rawData=[]; features=null; trainedModel=null;
      document.getElementById('btnFeat').disabled=true;
      document.getElementById('btnTrain').disabled=true;
      document.getElementById('btnUpdate').disabled=true;
      document.getElementById('btnCompare').disabled=true;
      document.getElementById('btnPred').disabled=true;
      document.getElementById('smape').textContent='-';
      document.getElementById('mae').textContent='-';
      clearResultsTable();
      if(clearChart && priceChart){priceChart.destroy();priceChart=null;}
      setStatus('Select an asset and load data to begin.');
      setDataSource('No Data');
      retrainCount = 0;
    }

    // ------------------------ Chart ------------------------
    function drawChart(){
      const ctx=document.getElementById('priceChart').getContext('2d');
      const cfg=cryptoConfig[currentCrypto];
      if(priceChart) priceChart.destroy();
      priceChart=new Chart(ctx,{
        type:'line',
        data:{
          labels:rawData.map(d=>d.date.toLocaleDateString()),
          datasets:[{
            label:`${cfg.name} price`,
            data:rawData.map(d=>d.price),
            borderColor:cfg.color,
            backgroundColor:cfg.color+'20',
            borderWidth:2,
            fill:true,
            pointRadius:0
          }]
        },
        options:{
          responsive:true,maintainAspectRatio:false,
          plugins:{legend:{labels:{color:'#fff'}}},
          scales:{
            x:{ticks:{color:'#fff',maxTicksLimit:8}},
            y:{ticks:{color:'#fff',callback:(v)=>'$'+(currentCrypto==='btc'?Math.round(v):Number(v).toFixed(3))}}
          }
        }
      });
    }

    // ------------------------ Features ------------------------
    function engineerFeatures(){
      const prices = rawData.map(d=>d.price);
      const dates  = rawData.map(d=>d.date);

      // Simple log returns
      const logret = prices.map((p,i)=> i===0?0:Math.log(p/prices[i-1]));

      // Rolling stats
      const W = 14;
      const rollMean=[], rollStd=[];
      for(let i=0;i<prices.length;i++){
        const s=Math.max(0,i-W+1);
        const seg=prices.slice(s,i+1);
        const m=seg.reduce((a,b)=>a+b,0)/seg.length;
        const v=seg.reduce((a,b)=>a+(b-m)*(b-m),0)/seg.length;
        rollMean.push(m);
        rollStd.push(Math.sqrt(v)+1e-8);
      }

      // Create sequences
      const L = 7;
      const X=[], y=[], idx=[];
      for(let i=L;i<prices.length-1;i++){
        const seq = logret.slice(i-L+1,i+1);
        const normPrice = (prices[i]-rollMean[i])/rollStd[i];
        const row = [...seq, normPrice];
        X.push(row);
        y.push((prices[i+1]-rollMean[i])/rollStd[i]);
        idx.push(i);
      }

      features = { X, y, idx, rollMean, rollStd, prices, dates, L };
      log(`Features ready: ${X.length} sequences`);
      document.getElementById('btnTrain').disabled=false;
      document.getElementById('btnCompare').disabled=false;
      setStatus(`Features engineered. Ready to train models.`);
    }

    // ------------------------ Training ------------------------
    async function trainModel(){
      if(!features){log('Engineer features first.');return;}
      const {X,y,idx,rollMean,rollStd,prices,L} = features;

      const [Xtr,Xte] = tsSplit(X,0.8);
      const [ytr,yte] = tsSplit(y,0.8);
      if(Xte.length<5){log('Need more data.');return;}

      // Baseline
      const baseNorm = Xte.map(row => row[row.length-1]);
      const baseSMAPE = smape(yte, baseNorm);

      const modelType = document.getElementById('modelType').value;
      let model;

      // Simple model architectures
      if(modelType==='linear'){
        model = tf.sequential({layers:[tf.layers.dense({inputShape:[Xtr[0].length],units:1})]});
        model.compile({optimizer:tf.train.adam(0.01),loss:'meanSquaredError'});
        const trainX = to2d(Xtr), trainY = tf.tensor2d(ytr,[ytr.length,1]);
        await model.fit(trainX, trainY, {epochs:50,batchSize:32,verbose:0});
        trainX.dispose(); trainY.dispose();
      } else if(modelType==='lstm'){
        const trainX3 = to3d(Xtr,L);
        const trainY = tf.tensor2d(ytr,[ytr.length,1]);
        model = tf.sequential({
          layers:[
            tf.layers.lstm({inputShape:[L,1],units:32}),
            tf.layers.dense({units:1})
          ]
        });
        model.compile({optimizer:tf.train.adam(0.01),loss:'meanSquaredError'});
        await model.fit(trainX3, trainY, {epochs:40,batchSize:16,verbose:0});
        trainX3.dispose(); trainY.dispose();
      } else {
        model = tf.sequential({
          layers:[
            tf.layers.dense({inputShape:[Xtr[0].length],units:32,activation:'relu'}),
            tf.layers.dense({units:16,activation:'relu'}),
            tf.layers.dense({units:1})
          ]
        });
        model.compile({optimizer:tf.train.adam(0.01),loss:'meanSquaredError'});
        const trainX = to2d(Xtr), trainY = tf.tensor2d(ytr,[ytr.length,1]);
        await model.fit(trainX, trainY, {epochs:60,batchSize:32,verbose:0});
        trainX.dispose(); trainY.dispose();
      }

      // Predictions
      let predArr;
      if(modelType==='lstm'){
        const testX3 = to3d(Xte,L);
        const yhat = await model.predict(testX3).array();
        predArr = yhat.map(v=>v[0]);
        testX3.dispose();
      } else {
        const testX = to2d(Xte);
        const yhat = await model.predict(testX).array();
        predArr = yhat.map(v=>v[0]);
        testX.dispose();
      }

      const modelSMAPE = smape(yte, predArr);

      // Denormalize for price metrics
      const start = idx.length - Xte.length;
      const denormTrue = [], denormPred = [], denormBase = [];
      for (let i = 0; i < Xte.length; i++) {
        const pos = idx[start + i];
        const mean = rollMean[pos], sd = rollStd[pos];
        denormTrue.push(yte[i]*sd + mean);
        denormPred.push(predArr[i]*sd + mean);
        denormBase.push(baseNorm[i]*sd + mean);
      }
      
      const modelMAE = mae(denormTrue, denormPred);
      const modelMAPE = mape(denormTrue, denormPred);
      const baseMAE = mae(denormTrue, denormBase);
      const baseMAPE = mape(denormTrue, denormBase);

      // Update UI
      document.getElementById('smape').textContent = modelSMAPE.toFixed(2) + '%';
      document.getElementById('mae').textContent = formatPrice(modelMAE);

      if (retrainCount === 0) {
        clearResultsTable();
        writeResultsRow('Baseline', baseMAE, baseMAPE, baseSMAPE);
      }
      writeResultsRow(modelType.toUpperCase(), modelMAE, modelMAPE, modelSMAPE);

      log(`${modelType}: MAE ${formatPrice(modelMAE)}, SMAPE ${modelSMAPE.toFixed(2)}%`);

      trainedModel = model;
      retrainCount += 1;
      document.getElementById('btnPred').disabled=false;
      document.getElementById('btnUpdate').disabled=false;
      setStatus('Model trained successfully. Ready for predictions.');
    }

    async function compareAll(){
      if (!features) { log('Engineer features first.'); return; }
      clearResultsTable();
      retrainCount = 0;

      const sel = document.getElementById('modelType');
      const original = sel.value;
      const models = ['linear','neural','lstm'];
      
      for (const m of models) {
        sel.value = m;
        log(`Training ${m}...`);
        await trainModel();
      }
      sel.value = original;
      setStatus('Model comparison complete.');
    }

    // ------------------------ Prediction ------------------------
    function makePrediction(){
      if(!trainedModel || !features) return;
      const {X,idx,rollMean,rollStd,prices,L} = features;
      const lastX = X[X.length-1];
      const modelType = document.getElementById('modelType').value;

      let yhatTensor;
      if(modelType==='lstm'){
        yhatTensor = trainedModel.predict(to3d([lastX], L));
      } else {
        yhatTensor = trainedModel.predict(to2d([lastX]));
      }

      yhatTensor.data().then(v=>{
        const norm = v[0];
        const i = idx[idx.length-1];
        const pred = norm*rollStd[i] + rollMean[i];
        const curr = prices[i];
        const chg = (pred/curr - 1)*100;
        log(`Current: ${formatPrice(curr)} → Next: ${formatPrice(pred)} (${chg>=0?'+':''}${chg.toFixed(2)}%)`);
        setStatus(`Prediction: ${formatPrice(pred)} (${chg>=0?'+':''}${chg.toFixed(2)}%)`);
      }).finally(()=>yhatTensor.dispose());
    }

    // ------------------------ Init ------------------------
    (function init(){
      log('🚀 Crypto ML platform ready');
      log('📊 Data sources: CoinGecko(Proxy) → CryptoCompare → Alpha Vantage → Realistic Sample');
      log('💡 Tip: Use "Compare all models" to test Linear, Neural, and LSTM together');
      log('⚠️ Browser CORS restrictions may prevent API access - high-quality sample data available');
      log('🚀 For production: Deploy with backend proxy to bypass CORS limitations');
      setStatus('Load real data to begin analysis (will use sample data if APIs fail).');
    })();
  </script>
</body>
</html>
